// Generated by CoffeeScript 1.3.3
(function() {

  (function($, window, document) {
    var Valitron, config, cust_translations, defaults, groups, translations, valitron_name;
    valitron_name = 'valitron';
    translations = {};
    cust_translations = {};
    groups = [];
    defaults = {
      rules: [],
      language: 'en',
      success: null,
      error: null,
      beforeValidate: null,
      afterValidate: null,
      valid: false,
      timeout: 500,
      timer: null,
      errors: {},
      pass: {},
      messages: {}
    };
    config = {
      globalSuccess: function(msg) {
        if ($.valitron("config", "bootstrap")) {
          return $(this).valitron("bootstrap", "unmark", "error");
        } else {
          return $(this).removeClass("error");
        }
      },
      globalError: function(msg) {
        if ($.valitron("config", "bootstrap")) {
          return $(this).valitron("bootstrap", "mark", "error");
        } else {
          return $(this).addClass("error");
        }
      },
      ruleDelimiter: "|",
      ruleMethodDelimiter: ":",
      ruleParamDelimiter: ",",
      ruleDataElement: 'validation',
      bootstrap: true
    };
    Valitron = function(element, options) {
      var _d_opts;
      this.el = element;
      this.$el = $(element);
      _d_opts = this._parseRules(this.$el.data(config.ruleDataElement));
      this.options = {};
      this.options = this._extendOptions(defaults);
      this.options = this._extendOptions(options);
      if (this.options.rules !== null || typeof this.options.rules !== "undefined") {
        this.options.rules = this.options.rules.concat(_d_opts);
      } else {
        this.options.rules = _d_opts;
      }
      this._name = valitron_name;
      return this.init();
    };
    Valitron.prototype = {
      _resolveValue: function(el) {
        if (el.is("input:text, input:password, input:hidden")) {
          return el.val();
        }
        if (el.is("input:checkbox, input:radio")) {
          return el.is(":checked");
        } else {
          return el.text();
        }
      },
      _parseRules: function(rules) {
        var rule, _tmp;
        rule = [];
        if (typeof rules !== "string") {
          return rule;
        }
        _tmp = rules != null ? rules.split(config.ruleDelimiter) : void 0;
        if (!_tmp) {
          return rule;
        }
        $.each(_tmp, function(idx, value) {
          var _t;
          if (typeof value === 'string' && value.length > 0) {
            _t = value.split(config.ruleMethodDelimiter);
            _t[0] = _t[0].trim();
            _t[1] = _t[1] !== void 0 && _t[1] !== null ? _t[1].split(config.ruleParamDelimiter) : null;
            return rule.push(_t);
          }
        });
        return rule;
      },
      _ruleMsg: function(res, type, msg) {
        var _r;
        _r = {
          result: res,
          type: type,
          message: msg
        };
        return _r;
      },
      _validMsg: function(type, msg) {
        return this._ruleMsg(true, type, msg);
      },
      _invalidMsg: function(type, msg) {
        return this._ruleMsg(false, type, msg);
      },
      _condMsg: function(cond, type, true_msg, false_smg) {
        if (cond) {
          return this._validMsg(type, true_msg);
        } else {
          return this._invalidMsg(type, false_smg);
        }
      },
      _extendRules: function(rules) {
        var _ref, _rls;
        _rls = this._parseRules(rules);
        if (((_ref = this.options) != null ? _ref.rules : void 0) != null) {
          _rls = this.options.rules.concat(_rls);
        }
        return _rls;
      },
      _extendOptions: function(options) {
        var _rls, _t_opts;
        if (this.options === null || typeof this.options === void 0) {
          return $.extend(true, this.options, defaults);
        }
        if (options === null || typeof options === void 0) {
          return this.options;
        }
        _rls = this._extendRules((options != null ? options.rules : void 0) != null);
        _t_opts = $.extend(true, {}, this.options, options);
        _t_opts.rules = _rls;
        return _t_opts;
      },
      _callBefore: function() {
        var _r_bfr;
        if (typeof this.options.beforeValidate === "function") {
          _r_bfr = this.options.beforeValidate.call(this.el, this.options);
        }
        if (_r_bfr === null || _r_bfr === void 0) {
          _r_bfr = this._resolveValue(this.$el);
        }
        return _r_bfr;
      },
      _callAfter: function(result) {
        if (typeof this.options.afterValidate === "function") {
          this.options.afterValidate.call(this.el, result);
        }
      },
      _callCallbacks: function(error, pass, options) {
        var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ret;
        if (error !== null && error !== void 0 && pass !== null && pass !== void 0) {
          if (this.isValid() === true) {
            if (typeof this.options.success === "function") {
              _ret = (_ref = this.options.success) != null ? _ref.call(this.el, pass, error) : void 0;
            } else {
              if ((_ref1 = config.globalSuccess) != null) {
                _ref1.call(this.el, pass, error);
              }
            }
            if (_ret) {
              if ((_ref2 = config.globalSuccess) != null) {
                _ref2.call(this.el, pass, error);
              }
            }
          } else {
            if (typeof this.options.error === "function") {
              _ret = (_ref3 = this.options.error) != null ? _ref3.call(this.el, error, pass) : void 0;
            } else {
              if ((_ref4 = config.globalError) != null) {
                _ref4.call(this.el, error, pass);
              }
            }
            if (_ret) {
              if ((_ref5 = config.globalError) != null) {
                _ref5.call(this.el, error, pass);
              }
            }
          }
        }
      },
      _attribute: function(attribute, lang) {
        var _ref, _ref1;
        lang = lang != null ? lang : this.options.language;
        if ((translations != null ? (_ref = translations[lang]) != null ? (_ref1 = _ref["attributes"]) != null ? _ref1[attribute] : void 0 : void 0 : void 0) != null) {
          return translations[lang]["attributes"][attribute];
        } else {
          return attribute;
        }
      },
      _replace: function(message, attribute, rule, value, parameters) {
        message = message.replace(":attribute", this._attribute(attribute));
        message = message.replace(":value", value);
        if (this.replacers[rule] != null) {
          message = this.replacers[rule](message, attribute, rule, parameters);
        }
        return message;
      },
      _translate_s: function(source, name, type) {
        var msg;
        if ((source != null ? source[name] : void 0) != null) {
          msg = source[name];
          if (typeof msg === "object") {
            if ((type != null) && (msg[type] != null)) {
              return msg[type];
            } else {
              return null;
            }
          } else {
            return msg;
          }
        } else {
          return null;
        }
        return null;
      },
      _translate: function(attribute, rule, lang, value, parameters, type, def) {
        var c_name, msg, _r1, _ref;
        lang = lang != null ? lang : this.options.language;
        c_name = attribute + "_" + rule;
        msg = this._translate_s(this.options.messages, c_name, type);
        if (msg != null) {
          return this._replace(msg, attribute, rule, value, parameters);
        }
        if ((translations != null ? (_ref = translations[lang]) != null ? _ref["custom"] : void 0 : void 0) != null) {
          _r1 = translations[lang]["custom"];
          msg = this._translate_s(_r1, c_name, type);
          if (msg != null) {
            return this._replace(msg, attribute, rule, value, parameters);
          }
        }
        msg = this._translate_s(this.options.messages, rule, type);
        if (msg != null) {
          return this._replace(msg, attribute, rule, value, parameters);
        }
        if ((translations != null ? translations[lang] : void 0) != null) {
          _r1 = translations[lang];
          msg = this._translate_s(_r1, rule, type);
          if (msg != null) {
            return this._replace(msg, attribute, rule, value, parameters);
          }
        }
        return def;
      },
      _translate_msg: function(msg, rule, value, parameters) {
        var name;
        name = (this.$el.attr("name") != null) && typeof this.$el.attr("name") !== "undefined" ? this.$el.attr("name") : this.$el.attr("id");
        msg = this._translate(name, rule, null, value, parameters, msg.type, msg.message);
        return msg;
      },
      _register: function(name, closure) {
        if (typeof closure === "function") {
          this.validations[name] = closure;
        } else {
          return this.validations[name];
        }
        return this;
      },
      _replacer: function(name, closure) {
        if (typeof closure === "function") {
          this.replacers[name] = closure;
        } else {
          return this.replacers[name];
        }
        return this;
      },
      init: function() {
        return "Test init";
      },
      validateRule: function(el, method, parameters, value) {
        var _ref;
        if (((el != null ? el.constructor : void 0) != null) === Array) {
          method = el[1];
          parameters = el[2];
          value = el[3];
          el = el[0];
        }
        return (_ref = this.validations[method]) != null ? _ref.call(this, el, parameters, value) : void 0;
      },
      validate: function(options) {
        var self, _errors, _pass, _r_bfr, _valid;
        this.options = this._extendOptions(options != null ? options[0] : void 0);
        self = this;
        _errors = [];
        _pass = [];
        _valid = true;
        _r_bfr = self._callBefore(self.options);
        $.each.call(this, this.options.rules, function(idx, value) {
          var msg, _re;
          _re = self.validateRule.call(self, self.$el, value[0], value[1], _r_bfr);
          msg = self._translate_msg(_re, value[0], _r_bfr, value[1]);
          if (_re.result === true) {
            _pass.push({
              rule: value[0],
              parameters: value[1],
              message: msg
            });
          } else {
            _errors.push({
              rule: value[0],
              parameters: value[1],
              message: msg
            });
          }
          if (_re.result === false) {
            _valid = false;
          }
        });
        this.options.valid = _valid;
        this.options.errors = _errors;
        this.options.pass = _pass;
        this._callCallbacks(_errors, _pass, this.options);
        this._callAfter(_errors.concat(_pass));
        return this.$el;
      },
      live: function(options) {
        var self, _opts;
        self = this;
        _opts = options[0];
        if (self.options.timer) {
          return this.$el;
        }
        this.options = this._extendOptions(_opts);
        self.$el.on('keypress', function() {
          if (self.options.timer) {
            clearTimeout(self.options.timer);
            self.options.timer = null;
          }
          self.options.timer = setTimeout( function() { self.validate() }, self.options.timeout );
        });
        return this.$el;
      },
      isValid: function() {
        return this.options.valid;
      },
      isInvalid: function() {
        return !this.options.valid;
      },
      translate: function(key) {},
      debug: function() {
        console.log(this.el);
        console.log(this.options);
        console.log(config);
        return this.$el;
      },
      config: function(options) {
        if (options != null) {
          $.extend(true, config, options);
          return this.$el;
        } else {
          return config;
        }
      },
      options: function(options) {
        if (options[0] != null) {
          defaults = this._extendOptions(options[0]);
          return this.$el;
        } else {
          return defaults;
        }
      },
      errors: function() {
        return this.options.errors;
      },
      bootstrap: function() {
        var cmd, grand, marking, parent;
        cmd = arguments[0][0];
        marking = arguments[0][1];
        if (cmd === "mark") {
          parent = this.$el.parent();
          if (parent.hasClass("controls") === true) {
            grand = parent.parent();
            if (grand.hasClass("control-group") === true) {
              grand.addClass(marking);
            }
          }
        }
        if (cmd === "unmark") {
          parent = this.$el.parent();
          if (parent.hasClass("controls") === true) {
            grand = parent.parent();
            if (grand.hasClass("control-group") === true) {
              return grand.removeClass(marking);
            }
          }
        }
      }
    };
    Valitron.prototype.validations = {
      max: function(el, parameters, value) {
        if (typeof value === "number" && value > parameters[0]) {
          return this._invalidMsg("number", "Number is bigger then " + parameters + "!");
        } else if (typeof value === "string" && value.length > parameters[0]) {
          return this._invalidMsg("string", "String is to long, should be max:" + parameters + "!");
        } else {
          return this._validMsg(null, "Grats man");
        }
      },
      min: function(el, parameters, value) {
        if (typeof value === "number" && value < parameters[0]) {
          return this._invalidMsg("number", "Number is smaller then " + parameters + "!");
        } else if (typeof value === "string" && value.length < parameters[0]) {
          return this._invalidMsg("string", "String should be at least " + parameters + " characters length!");
        } else {
          return this._validMsg(null, "Grats man");
        }
      },
      size: function(el, parameters, value) {
        if (value.length === parameters[0]) {
          return this._validMsg(null, "Size is good.");
        } else {
          return this._invalidMsg(null, "Attribute must be required size!");
        }
      },
      between: function(el, parameters, value) {
        if ((parameters[0] != null) && (parameters[1] != null)) {
          if (value < parameters[0] || value > parameters[1]) {
            return this._invalidMsg(null, "Value must be between " + parameters[0] + " and " + parameters[1]);
          } else {
            return this._validMsg(null, "Value is between " + parameters[0] + " and " + parameters[1]);
          }
        } else {
          return this._invalidMsg(null, "Bad parameters provided");
        }
      },
      numeric: function(el, parameters, value) {},
      integer: function(el, parameters, value) {
        var patern;
        patern = /^\-?\d+$/;
        if (patern.test(value)) {
          return this._validMsg(null, "Its integer allright.");
        } else {
          return this._invalidMsg(null, "Not integer man.");
        }
      },
      required: function(el, parameters, value) {
        if (value === null || value === void 0) {
          return this._invalidMsg(null, "Value must be set to something!");
        } else if (typeof value === "string" && (value.length <= 0 || value === "")) {
          return this._invalidMsg(null, "Value must be set to something!");
        } else if (typeof value === "boolean" || typeof value === "number") {
          if (Boolean(value)) {
            return this._validMsg(null, "Grats man");
          } else {
            return this._invalidMsg(null, "Value must be set to something!");
          }
        } else {
          return this._validMsg(null, "Grats man");
        }
      },
      same: function(el, parameters, value) {
        var param, _i, _len;
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          param = parameters[_i];
          if (value !== param) {
            return this._invalidMsg(null, "Values is not same");
          }
        }
        return this._validMsg(null, "Great, same values!");
      },
      accepted: function(el, parameters, value) {
        if (Boolean(value)) {
          return this._validMsg(null, "Value is accepted");
        } else {
          return this._invalidMsg(null, "You must accepts this!");
        }
      },
      different: function(el, parameters, value) {},
      "in": function(el, parameters, value) {
        if ($.inArray(value, parameters[0].split(config.ruleParamDelimiter)) > -1) {
          return this._validMsg(null, "Value is in array.");
        } else {
          return this._invalidMsg(null, ("" + value + " must be in ") + parameters[0] + "!");
        }
      },
      not_id: function(el, parameters, value) {
        if ($.inArray(value, parameters[0].split(config.ruleParamDelimiter)) > -1) {
          return this._invalidMsg(null, ("" + value + " must NOT be in ") + parameters[0] + "!");
        } else {
          return this._validMsg(null, "Value is not in array.");
        }
      },
      unique: function(el, parameters, value) {
        return console.log("Working on it...");
      },
      exists: function(el, parameters, value) {
        return console.log("Working on it...");
      },
      ipv4: function(el, parameters, value) {
        var pattern;
        pattern = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/g;
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "Good IPv4 address");
          } else {
            return this._invalidMsg(null, "Invalid address");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      email: function(el, parameters, value) {
        var patern;
        patern = "[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?";
        if (patern.test(value)) {
          return this._validMsg(null, "E-mail is valid.");
        } else {
          return this._invalidMsg(null, "Invalid e-mail, please fix it now!");
        }
      },
      url: function(el, parameters, value) {
        return console.log("Open for suggestions...");
      },
      alpha: function(el, parameters, value) {
        var pattern;
        pattern = /^([a-z])+$/i;
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      alpha_num: function(el, parameters, value) {
        var pattern;
        pattern = /^([a-z0-9])+$/i;
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      alpha_dash: function(el, parameters, value) {
        var pattern;
        pattern = /^([-a-z0-9_-])+$/i;
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      match: function(el, parameters, value) {
        var pattern;
        pattern = parameters[0];
        if (typeof value === "string") {
          if (pattern != null ? pattern.test(value) : void 0) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      before: function(el, parameters, value) {
        if (Date(value < Date(parameters[0]))) {
          return this._validMsg(null, "" + value + " is before " + parameters[0]);
        } else {
          return this._invalidMsg(null, "" + value + " must be  before " + parameters[0]);
        }
      },
      after: function(el, parameters, value) {
        if (Date(value > Date(parameters[0]))) {
          return this._validMsg(null, ("" + value + " is after ") + parameters[0]);
        } else {
          return this._invalidMsg(null, ("" + value + " must be  after ") + parameters[0]);
        }
      }
    };
    Valitron.prototype.replacers = {
      max: function(message, attribute, rule, parameters) {
        return message.replace(":max", parameters[0]);
      },
      min: function(message, attribute, rule, parameters) {
        return message.replace(":min", parameters[0]);
      }
    };
    $.fn[valitron_name] = function(method, opts) {
      var args, elms, options, rule_patt, _t;
      options = opts;
      args = Array.prototype.slice.call(arguments, 1);
      rule_patt = /^rule_/i;
      if (this.is("form")) {
        elms = this.find('[data-validation]');
      } else {
        elms = this;
      }
      _t = $.map(elms, function(el, idx) {
        var _ref, _ret, _val;
        _val = $.data(el, valitron_name);
        if (!_val) {
          $.data(el, valitron_name, _val = new Valitron(el));
        }
        if (rule_patt.test(method)) {
          return (_ref = _val.validations[method.substr(5)]) != null ? _ref.apply(_val, args) : void 0;
        }
        if (typeof _val[method] === "function" && method.charAt(0 !== "_")) {
          _ret = _val[method](args);
          if (_ret != null) {
            return _ret;
          } else {
            return $(el);
          }
        } else if (typeof method === 'object') {
          _val.setOptions(method);
          return $(el);
        } else {
          $.error("Method " + method + " does not exists on jQuery.valitron");
        }
        return $(el);
      });
      return _t[0];
    };
    $.valitron = function(el, options, opt2) {
      if (typeof el === "string") {
        if (el === "config") {
          if ((options != null) && typeof options === "object") {
            $.extend(true, config, options);
            return this.$el;
          } else if (typeof options === "string") {
            return config[options];
          } else {
            return config;
          }
        } else if (el === "options") {
          if ((options != null) && typeof options === "object") {
            defaults = this._extendOptions(options);
            return this.$el;
          } else if (typeof options === "string") {
            return defaults[options];
          } else {
            return defaults;
          }
        } else if (el === "translation") {
          if ((options != null) && typeof options === "object") {
            $.extend(true, translations, options);
            return this.$el;
          } else if (typeof options === "string") {
            return translations[options];
          } else {
            return translations;
          }
        } else if (el === "rule" && typeof options === "string" && typeof opt2 === "function") {
          this._register(options(opt2));
        } else if (el === "replacer" && typeof options === "string" && typeof opt2 === "function") {
          this._replacer(options(opt2));
        }
      }
      return $.fn[valitron_name].apply(el, Array.prototype.slice.call(arguments, 1));
    };
  })(jQuery, window, document);

}).call(this);
