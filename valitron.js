// Generated by CoffeeScript 1.3.3
(function() {

  (function($, window, document) {
    var Valitron, config, defaults, valitron_name;
    valitron_name = 'valitron';
    defaults = {
      rules: [],
      language: 'en',
      success: null,
      error: null,
      beforeValidate: null,
      afterValidate: null,
      valid: false
    };
    config = {
      globSuccess: function(msg) {
        return $(this).removeClass("error");
      },
      globError: function(msg) {
        return $(this).addClass("error");
      },
      ruleDelimiter: "|",
      ruleMethodDelimiter: ":",
      ruleParamDelimiter: ",",
      ruleDataElement: 'validation'
    };
    Valitron = function(element, options) {
      var _d_opts;
      this.el = element;
      this.$el = $(element);
      _d_opts = this._parseRules(this.$el.data(config.ruleDataElement));
      this.options = {};
      this.options = this._extendOptions(defaults);
      this.options = this._extendOptions(options);
      if (this.options.rules !== null || typeof this.options.rules !== "undefined") {
        this.options.rules = this.options.rules.concat(_d_opts);
      } else {
        this.options.rules = _d_opts;
      }
      this._name = valitron_name;
      return this.init();
    };
    Valitron.prototype = {
      _resolveValue: function(el) {
        if (el.is("input:text, input:password, input:hidden")) {
          return el.val();
        }
        if (el.is("input:checkbox, input:radio")) {
          return el.is(":checked");
        } else {
          return el.text();
        }
      },
      _parseRules: function(rules) {
        var rule, _tmp;
        rule = [];
        if (typeof rules !== "string") {
          return rule;
        }
        _tmp = rules != null ? rules.split(config.ruleDelimiter) : void 0;
        if (!_tmp) {
          return rule;
        }
        $.each(_tmp, function(idx, value) {
          var _t;
          if (typeof value === 'string' && value.length > 0) {
            _t = value.split(config.ruleMethodDelimiter);
            _t[0] = _t[0].trim();
            _t[1] = _t[1] !== void 0 && _t[1] !== null ? _t[1].split(config.ruleParamDelimiter) : null;
            return rule.push(_t);
          }
        });
        return rule;
      },
      check: function(method, parameters, options) {
        var _re, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ret, _val;
        if (typeof options.beforeValidate === "function") {
          _val = options.beforeValidate.call(this.el, method, parameters, options);
        }
        if (_val === null || _val === void 0) {
          _val = this._resolveValue(this.$el);
        }
        _re = (_ref = this.validations[method]) != null ? _ref.call(this, this.$el, parameters, _val) : void 0;
        if (_re !== null && _re !== void 0) {
          if (_re.result === true) {
            if (typeof options.success === "function") {
              _ret = (_ref1 = options.success) != null ? _ref1.call(this.el, _re.message, method, parameters) : void 0;
            } else {
              if ((_ref2 = config.globSuccess) != null) {
                _ref2.call(this.el, _re.message, method, parameters);
              }
            }
            if (_ret) {
              if ((_ref3 = config.globSuccess) != null) {
                _ref3.call(this.el, _re.message, method, parameters);
              }
            }
          } else {
            if (typeof options.error === "function") {
              _ret = (_ref4 = options.error) != null ? _ref4.call(this.el, _re.message, method, parameters) : void 0;
            } else {
              if ((_ref5 = config.globError) != null) {
                _ref5.call(this.el, _re.message, method, parameters);
              }
            }
            if (_ret) {
              if ((_ref6 = config.globError) != null) {
                _ref6.call(this.el, _re.message, method, parameters);
              }
            }
          }
          if (typeof options.afterValidate === "function") {
            options.afterValidate.call(this.el, _re.result, _re.message, method, parameters);
          }
        }
        return _re;
      },
      _ruleMsg: function(res, transl, msg) {
        var _r;
        _r = {
          result: res,
          translation: transl,
          message: msg
        };
        return _r;
      },
      _validMsg: function(transl, msg) {
        return this._ruleMsg(true, transl, msg);
      },
      _invalidMsg: function(transl, msg) {
        return this._ruleMsg(false, transl, msg);
      },
      _extendRules: function(rules) {
        var _ref, _rls;
        _rls = this._parseRules(rules);
        if (((_ref = this.options) != null ? _ref.rules : void 0) != null) {
          _rls = this.options.rules.concat(_rls);
        }
        return _rls;
      },
      _extendOptions: function(options) {
        var _rls, _t_opts;
        if (options === null || typeof options === "undefined") {
          return $.extend(true, {}, defaults);
        }
        _rls = this._extendRules((options != null ? options.rules : void 0) != null);
        _t_opts = $.extend(true, {}, this.options, options);
        _t_opts.rules = _rls;
        return _t_opts;
      },
      init: function() {},
      validate: function(options) {
        var self, _valid;
        this.options = this._extendOptions(options);
        self = this;
        _valid = true;
        $.each.call(this, this.options.rules, function(idx, value) {
          var _re;
          _re = self.check(value[0], value[1], self.options);
          if (_re.result === false) {
            _valid = false;
          }
        });
        this.options.valid = _valid;
        return this.$el;
      },
      isValid: function() {
        return this.options.valid;
      },
      isInvalid: function() {
        return !this.options.valid;
      },
      debug: function() {
        console.log(this.el);
        console.log(this.options);
        return console.log(config);
      }
    };
    Valitron.prototype.validations = {
      max: function(el, parameters, value) {
        if (typeof value === "number" && value > parameters[0]) {
          return this._invalidMsg(null, "Number is bigger then " + parameters + "!");
        } else if (typeof value === "string" && value.length > parameters[0]) {
          return this._invalidMsg(null, "String is to long, should be max:" + parameters + "!");
        } else {
          return this._validMsg(null, "Grats man");
        }
      },
      min: function(el, parameters, value) {
        if (typeof value === "number" && value < parameters[0]) {
          return this._invalidMsg(null, "Number is smaller then " + parameters + "!");
        } else if (typeof value === "string" && value.length < parameters[0]) {
          return this._invalidMsg(null, "String should be at least " + parameters + " characters length!");
        } else {
          return this._validMsg(null, "Grats man");
        }
      },
      size: function(el, parameters, value) {
        if (value.length === parameters[0]) {
          return this._validMsg(null, "Size is good.");
        } else {
          return this._invalidMsg(null, "Attribute must be required size!");
        }
      },
      between: function(el, parameters, value) {
        if ((parameters[0] != null) && (parameters[1] != null)) {
          if (value < parameters[0] || value > parameters[1]) {
            return this._invalidMsg(null, "Value must be between " + parameters[0] + " and " + parameters[1]);
          } else {
            return this._validMsg(null, "Value is between " + parameters[0] + " and " + parameters[1]);
          }
        } else {
          return this._invalidMsg(null, "Bad parameters provided");
        }
      },
      numeric: function(el, parameters, value) {},
      integer: function(el, parameters, value) {
        var patern;
        patern = /^\-?\d+$/;
        if (patern.test(value)) {
          return this._validMsg(null, "Its integer allright.");
        } else {
          return this._invalidMsg(null, "Not integer man.");
        }
      },
      required: function(el, parameters, value) {
        if (value === null || value === void 0) {
          return this._invalidMsg(null, "Value must be set to something!");
        } else if (typeof value === "string" && (value.length <= 0 || value === "")) {
          return this._invalidMsg(null, "Value must be set to something!");
        } else if (typeof value === "boolean" || typeof value === "number") {
          if (Boolean(value)) {
            return this._validMsg(null, "Grats man");
          } else {
            return this._invalidMsg(null, "Value must be set to something!");
          }
        } else {
          return this._validMsg(null, "Grats man");
        }
      },
      same: function(el, parameters, value) {
        var param, _i, _len;
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          param = parameters[_i];
          if (value !== param) {
            return this._invalidMsg(null, "Values is not same");
          }
        }
        return this._validMsg(null, "Great, same values!");
      },
      accepted: function(el, parameters, value) {
        if (Boolean(value)) {
          return this._validMsg(null, "Value is accepted");
        } else {
          return this._invalidMsg(null, "You must accepts this!");
        }
      },
      different: function(el, parameters, value) {},
      "in": function(el, parameters, value) {
        if ($.inArray(value, parameters[0].split(config.ruleParamDelimiter)) > -1) {
          return this._validMsg(null, "Value is in array.");
        } else {
          return this._invalidMsg(null, ("" + value + " must be in ") + parameters[0] + "!");
        }
      },
      not_id: function(el, parameters, value) {
        if ($.inArray(value, parameters[0].split(config.ruleParamDelimiter)) > -1) {
          return this._invalidMsg(null, ("" + value + " must NOT be in ") + parameters[0] + "!");
        } else {
          return this._validMsg(null, "Value is not in array.");
        }
      },
      unique: function(el, parameters, value) {
        return console.log("Working on it...");
      },
      exists: function(el, parameters, value) {
        return console.log("Working on it...");
      },
      ipv4: function(el, parameters, value) {
        var pattern;
        pattern = "/^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/g";
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "Good IPv4 address");
          } else {
            return this._invalidMsg(null, "Invalid address");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      email: function(el, parameters, value) {
        var patern;
        patern = "[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?";
        if (patern.test(value)) {
          return this._validMsg(null, "E-mail is valid.");
        } else {
          return this._invalidMsg(null, "Invalid e-mail, please fix it now!");
        }
      },
      url: function(el, parameters, value) {
        return console.log("Open for suggestions...");
      },
      alpha: function(el, parameters, value) {
        var pattern;
        pattern = '/^([a-z])+$/i';
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      alpha_num: function(el, parameters, value) {
        var pattern;
        pattern = '/^([a-z0-9])+$/i';
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      alpha_dash: function(el, parameters, value) {
        var pattern;
        pattern = '/^([-a-z0-9_-])+$/i';
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      match: function(el, parameters, value) {
        var pattern;
        pattern = parameters[0];
        if (typeof value === "string") {
          if (pattern != null ? pattern.test(value) : void 0) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      before: function(el, parameters, value) {
        if (Date(value < Date(parameters[0]))) {
          return this._validMsg(null, "" + value + " is before " + parameters[0]);
        } else {
          return this._invalidMsg(null, "" + value + " must be  before " + parameters[0]);
        }
      },
      after: function(el, parameters, value) {
        if (Date(value > Date(parameters[0]))) {
          return this._validMsg(null, ("" + value + " is after ") + parameters[0]);
        } else {
          return this._invalidMsg(null, ("" + value + " must be  after ") + parameters[0]);
        }
      }
    };
    $.fn[valitron_name] = function(method, opts) {
      var options;
      options = opts;
      return this.each(function() {
        var _val;
        _val = $.data(this, valitron_name);
        if (!_val) {
          $.data(this, valitron_name, _val = new Valitron(this));
        }
        if (typeof _val[method] === "function" && method.charAt(0 !== "_")) {
          return _val[method](options);
        } else if (typeof method === 'object') {
          return _val.setOptions(method);
        } else {
          return $.error("Method " + method + " does not exists on jQuery.valitron");
        }
      });
    };
    $.valitron = function(cfg, options) {
      if ((options != null) && typeof options !== void 0) {
        if (cfg === "config") {
          return $.extend(true, config, options);
        }
        if (cfg === "rule_defaults") {
          return $.extend(true, defaults, options);
        }
      } else {
        if (cfg === "config") {
          return config;
        }
        if (cfg === "rule_defaults") {
          return defaults;
        }
      }
    };
  })(jQuery, window, document);

}).call(this);
