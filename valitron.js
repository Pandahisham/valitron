// Generated by CoffeeScript 1.3.3
(function() {

  (function($, window, document) {
    var Valitron, config, defaults, groups, translations, valitron_name;
    valitron_name = 'valitron';
    translations = {};
    groups = [];
    defaults = {
      rules: [],
      language: 'en',
      success: null,
      error: null,
      beforeValidate: null,
      afterValidate: null,
      valid: false,
      timeout: 500,
      timer: null
    };
    config = {
      globalSuccess: function(msg) {
        var grand, parent;
        if ($.valitron("config", "bootstrap")) {
          parent = $(this).parent();
          if (parent.hasClass("controls") === true) {
            grand = parent.parent();
            if (grand.hasClass("control-group") === true) {
              grand = removeClass("error");
            }
          }
        } else {
          $(this).removeClass("error");
        }
        return console.log("GLOBAL SUCCESS:", msg, this);
      },
      globalError: function(msg) {
        var grand, parent;
        if ($.valitron("config", "bootstrap")) {
          parent = $(this).parent();
          if (parent.hasClass("controls") === true) {
            grand = parent.parent();
            if (grand.hasClass("control-group") === true) {
              grand = addClass("error");
            }
          }
        } else {
          $(this).addClass("error");
        }
        return console.log("GLOBAL ERROR:", msg, this);
      },
      ruleDelimiter: "|",
      ruleMethodDelimiter: ":",
      ruleParamDelimiter: ",",
      ruleDataElement: 'validation',
      bootstrap: true
    };
    Valitron = function(element, options) {
      var _d_opts;
      this.el = element;
      this.$el = $(element);
      _d_opts = this._parseRules(this.$el.data(config.ruleDataElement));
      this.options = {};
      this.options = this._extendOptions(defaults);
      this.options = this._extendOptions(options);
      if (this.options.rules !== null || typeof this.options.rules !== "undefined") {
        this.options.rules = this.options.rules.concat(_d_opts);
      } else {
        this.options.rules = _d_opts;
      }
      this._name = valitron_name;
      return this.init();
    };
    Valitron.prototype = {
      _resolveValue: function(el) {
        if (el.is("input:text, input:password, input:hidden")) {
          return el.val();
        }
        if (el.is("input:checkbox, input:radio")) {
          return el.is(":checked");
        } else {
          return el.text();
        }
      },
      _parseRules: function(rules) {
        var rule, _tmp;
        rule = [];
        if (typeof rules !== "string") {
          return rule;
        }
        _tmp = rules != null ? rules.split(config.ruleDelimiter) : void 0;
        if (!_tmp) {
          return rule;
        }
        $.each(_tmp, function(idx, value) {
          var _t;
          if (typeof value === 'string' && value.length > 0) {
            _t = value.split(config.ruleMethodDelimiter);
            _t[0] = _t[0].trim();
            _t[1] = _t[1] !== void 0 && _t[1] !== null ? _t[1].split(config.ruleParamDelimiter) : null;
            return rule.push(_t);
          }
        });
        return rule;
      },
      _ruleMsg: function(res, transl, msg) {
        var _r;
        _r = {
          result: res,
          translation: transl,
          message: msg
        };
        return _r;
      },
      _validMsg: function(transl, msg) {
        return this._ruleMsg(true, transl, msg);
      },
      _invalidMsg: function(transl, msg) {
        return this._ruleMsg(false, transl, msg);
      },
      _condMsg: function(cond, true_transl, true_msg, false_transl, false_smg) {
        if (cond) {
          return this._validMsg(true_transl, true_msg);
        } else {
          return this._invalidMsg(false_transl, false_smg);
        }
      },
      _extendRules: function(rules) {
        var _ref, _rls;
        _rls = this._parseRules(rules);
        if (((_ref = this.options) != null ? _ref.rules : void 0) != null) {
          _rls = this.options.rules.concat(_rls);
        }
        return _rls;
      },
      _extendOptions: function(options) {
        var _rls, _t_opts;
        if (this.options === null || typeof this.options === void 0) {
          return $.extend(true, this.options, defaults);
        }
        if (options === null || typeof options === void 0) {
          return this.options;
        }
        _rls = this._extendRules((options != null ? options.rules : void 0) != null);
        _t_opts = $.extend(true, {}, this.options, options);
        _t_opts.rules = _rls;
        return _t_opts;
      },
      _callBefore: function() {
        var _r_bfr;
        if (typeof this.options.beforeValidate === "function") {
          _r_bfr = this.options.beforeValidate.call(this.el(this.options));
        }
        if (_r_bfr === null || _r_bfr === void 0) {
          _r_bfr = this._resolveValue(this.$el);
        }
        return _r_bfr;
      },
      _callAfter: function(result) {
        if (typeof this.options.afterValidate === "function") {
          this.options.afterValidate.call(this.el, result);
        }
      },
      _callCallbacks: function(result, options) {
        var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ret;
        if (result !== null && result !== void 0) {
          if (this.isValid() === true) {
            if (typeof this.options.success === "function") {
              _ret = (_ref = this.options.success) != null ? _ref.call(this.el, result) : void 0;
            } else {
              if ((_ref1 = config.globalSuccess) != null) {
                _ref1.call(this.el, result);
              }
            }
            if (_ret) {
              if ((_ref2 = config.globalSuccess) != null) {
                _ref2.call(this.el, result);
              }
            }
          } else {
            if (typeof this.options.error === "function") {
              _ret = (_ref3 = this.options.error) != null ? _ref3.call(this.el, result) : void 0;
            } else {
              if ((_ref4 = config.globalError) != null) {
                _ref4.call(this.el, result);
              }
            }
            if (_ret) {
              if ((_ref5 = config.globalError) != null) {
                _ref5.call(this.el, result);
              }
            }
          }
        }
      },
      init: function() {
        return "Test init";
      },
      validateRule: function(el, method, parameters, value) {
        var _ref;
        if (((el != null ? el.constructor : void 0) != null) === Array) {
          method = el[1];
          parameters = el[2];
          value = el[3];
          el = el[0];
        }
        return (_ref = this.validations[method]) != null ? _ref.call(this, el, parameters, value) : void 0;
      },
      validate: function(options) {
        var self, _r_bfr, _result, _valid;
        this.options = this._extendOptions(options != null ? options[0] : void 0);
        self = this;
        _result = [];
        _valid = true;
        _r_bfr = self._callBefore(self.options);
        $.each.call(this, this.options.rules, function(idx, value) {
          var _re;
          _re = self.validateRule.call(self, self.$el, value[0], value[1], _r_bfr);
          _result.push({
            result: _re.result,
            rule: value[0],
            parameters: value[1],
            message: _re.message,
            translation: _re.translation
          });
          if (_re.result === false) {
            _valid = false;
          }
        });
        this.options.valid = _valid;
        this._callCallbacks(_result, this.options);
        this._callAfter;
        return this.$el;
      },
      live: function(options) {
        var self, _opts;
        self = this;
        _opts = options[0];
        if (self.options.timer) {
          return this.$el;
        }
        this.options = this._extendOptions(_opts);
        self.$el.on('keypress', function() {
          if (self.options.timer) {
            clearTimeout(self.options.timer);
            self.options.timer = null;
          }
          self.options.timer = setTimeout( function() { self.validate() }, self.options.timeout );
        });
        return this.$el;
      },
      isValid: function() {
        return this.options.valid;
      },
      isInvalid: function() {
        return !this.options.valid;
      },
      translate: function(key) {},
      register: function(name, closure) {},
      debug: function() {
        console.log(this.el);
        console.log(this.options);
        console.log(config);
        return this.$el;
      },
      config: function(options) {
        if (options != null) {
          $.extend(true, config, options);
          return this.$el;
        } else {
          return config;
        }
      },
      options: function(options) {
        if (options[0] != null) {
          defaults = this._extendOptions(options[0]);
          return this.$el;
        } else {
          return defaults;
        }
      }
    };
    Valitron.prototype.validations = {
      max: function(el, parameters, value) {
        if (typeof value === "number" && value > parameters[0]) {
          return this._invalidMsg(null, "Number is bigger then " + parameters + "!");
        } else if (typeof value === "string" && value.length > parameters[0]) {
          return this._invalidMsg(null, "String is to long, should be max:" + parameters + "!");
        } else {
          return this._validMsg(null, "Grats man");
        }
      },
      min: function(el, parameters, value) {
        if (typeof value === "number" && value < parameters[0]) {
          return this._invalidMsg(null, "Number is smaller then " + parameters + "!");
        } else if (typeof value === "string" && value.length < parameters[0]) {
          return this._invalidMsg(null, "String should be at least " + parameters + " characters length!");
        } else {
          return this._validMsg(null, "Grats man");
        }
      },
      size: function(el, parameters, value) {
        if (value.length === parameters[0]) {
          return this._validMsg(null, "Size is good.");
        } else {
          return this._invalidMsg(null, "Attribute must be required size!");
        }
      },
      between: function(el, parameters, value) {
        if ((parameters[0] != null) && (parameters[1] != null)) {
          if (value < parameters[0] || value > parameters[1]) {
            return this._invalidMsg(null, "Value must be between " + parameters[0] + " and " + parameters[1]);
          } else {
            return this._validMsg(null, "Value is between " + parameters[0] + " and " + parameters[1]);
          }
        } else {
          return this._invalidMsg(null, "Bad parameters provided");
        }
      },
      numeric: function(el, parameters, value) {},
      integer: function(el, parameters, value) {
        var patern;
        patern = /^\-?\d+$/;
        if (patern.test(value)) {
          return this._validMsg(null, "Its integer allright.");
        } else {
          return this._invalidMsg(null, "Not integer man.");
        }
      },
      required: function(el, parameters, value) {
        if (value === null || value === void 0) {
          return this._invalidMsg(null, "Value must be set to something!");
        } else if (typeof value === "string" && (value.length <= 0 || value === "")) {
          return this._invalidMsg(null, "Value must be set to something!");
        } else if (typeof value === "boolean" || typeof value === "number") {
          if (Boolean(value)) {
            return this._validMsg(null, "Grats man");
          } else {
            return this._invalidMsg(null, "Value must be set to something!");
          }
        } else {
          return this._validMsg(null, "Grats man");
        }
      },
      same: function(el, parameters, value) {
        var param, _i, _len;
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          param = parameters[_i];
          if (value !== param) {
            return this._invalidMsg(null, "Values is not same");
          }
        }
        return this._validMsg(null, "Great, same values!");
      },
      accepted: function(el, parameters, value) {
        if (Boolean(value)) {
          return this._validMsg(null, "Value is accepted");
        } else {
          return this._invalidMsg(null, "You must accepts this!");
        }
      },
      different: function(el, parameters, value) {},
      "in": function(el, parameters, value) {
        if ($.inArray(value, parameters[0].split(config.ruleParamDelimiter)) > -1) {
          return this._validMsg(null, "Value is in array.");
        } else {
          return this._invalidMsg(null, ("" + value + " must be in ") + parameters[0] + "!");
        }
      },
      not_id: function(el, parameters, value) {
        if ($.inArray(value, parameters[0].split(config.ruleParamDelimiter)) > -1) {
          return this._invalidMsg(null, ("" + value + " must NOT be in ") + parameters[0] + "!");
        } else {
          return this._validMsg(null, "Value is not in array.");
        }
      },
      unique: function(el, parameters, value) {
        return console.log("Working on it...");
      },
      exists: function(el, parameters, value) {
        return console.log("Working on it...");
      },
      ipv4: function(el, parameters, value) {
        var pattern;
        pattern = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/g;
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "Good IPv4 address");
          } else {
            return this._invalidMsg(null, "Invalid address");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      email: function(el, parameters, value) {
        var patern;
        patern = "[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?";
        if (patern.test(value)) {
          return this._validMsg(null, "E-mail is valid.");
        } else {
          return this._invalidMsg(null, "Invalid e-mail, please fix it now!");
        }
      },
      url: function(el, parameters, value) {
        return console.log("Open for suggestions...");
      },
      alpha: function(el, parameters, value) {
        var pattern;
        pattern = /^([a-z])+$/i;
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      alpha_num: function(el, parameters, value) {
        var pattern;
        pattern = /^([a-z0-9])+$/i;
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      alpha_dash: function(el, parameters, value) {
        var pattern;
        pattern = /^([-a-z0-9_-])+$/i;
        if (typeof value === "string") {
          if (pattern.test(value)) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      match: function(el, parameters, value) {
        var pattern;
        pattern = parameters[0];
        if (typeof value === "string") {
          if (pattern != null ? pattern.test(value) : void 0) {
            return this._validMsg(null, "This is alpha only");
          } else {
            return this._invalidMsg(null, "Invalid value, can be only letters");
          }
        } else {
          return this._invalidMsg(null, "Cant check this type of value");
        }
      },
      before: function(el, parameters, value) {
        if (Date(value < Date(parameters[0]))) {
          return this._validMsg(null, "" + value + " is before " + parameters[0]);
        } else {
          return this._invalidMsg(null, "" + value + " must be  before " + parameters[0]);
        }
      },
      after: function(el, parameters, value) {
        if (Date(value > Date(parameters[0]))) {
          return this._validMsg(null, ("" + value + " is after ") + parameters[0]);
        } else {
          return this._invalidMsg(null, ("" + value + " must be  after ") + parameters[0]);
        }
      }
    };
    $.fn[valitron_name] = function(method, opts) {
      var args, options, rule_patt, _t;
      options = opts;
      args = Array.prototype.slice.call(arguments, 1);
      rule_patt = /^rule_/i;
      _t = $.map(this, function(el, idx) {
        var _ref, _ret, _val;
        _val = $.data(el, valitron_name);
        if (!_val) {
          $.data(el, valitron_name, _val = new Valitron(el));
        }
        if (rule_patt.test(method)) {
          return (_ref = _val.validations[method.substr(5)]) != null ? _ref.apply(_val, args) : void 0;
        }
        if (typeof _val[method] === "function" && method.charAt(0 !== "_")) {
          _ret = _val[method](args);
          if (_ret != null) {
            return _ret;
          } else {
            return $(el);
          }
        } else if (typeof method === 'object') {
          _val.setOptions(method);
          return $(el);
        } else {
          $.error("Method " + method + " does not exists on jQuery.valitron");
        }
        return $(el);
      });
      return _t[0];
    };
    $.valitron = function(el, options) {
      if (typeof el === "string") {
        if (el === "config") {
          if ((options != null) && typeof options === "object") {
            $.extend(true, config, options);
            console.log("set config:", options);
            return this.$el;
          } else if (typeof options === "string") {
            console.log("get config:", options);
            return config.bootstrap;
          } else {
            return config;
          }
        } else if (el === "options") {
          if ((options != null) && typeof options === "object") {
            defaults = this._extendOptions(options);
            return this.$el;
          } else if (typeof options === "string") {
            return defaults.options;
          } else {
            return defaults;
          }
        }
      }
      return $.fn[valitron_name].apply(el, Array.prototype.slice.call(arguments, 1));
    };
  })(jQuery, window, document);

}).call(this);
